"""Unified memory manager.

Provides a single interface to both ChromaDB (semantic memories)
and SQLite (user profiles, sessions) storage backends.
"""

from __future__ import annotations

import asyncio
import uuid
from datetime import datetime
from pathlib import Path

from reachy_agent.memory.storage.chroma_store import ChromaMemoryStore
from reachy_agent.memory.storage.sqlite_store import SQLiteProfileStore
from reachy_agent.memory.types import (
    Memory,
    MemoryType,
    SearchResult,
    SessionSummary,
    UserProfile,
)
from reachy_agent.utils.logging import get_logger

log = get_logger(__name__)


class MemoryManager:
    """Unified interface for the memory system.

    Coordinates between ChromaDB for semantic memories and SQLite
    for user profiles and session summaries.

    Args:
        chroma_path: Path to ChromaDB persistence directory.
        sqlite_path: Path to SQLite database file.
        embedding_model: Name of sentence-transformers model.
        retention_days: Days to retain memories before cleanup.

    Example:
        >>> manager = MemoryManager(
        ...     chroma_path="~/.reachy/memory/chroma",
        ...     sqlite_path="~/.reachy/memory/reachy.db",
        ... )
        >>> await manager.initialize()
        >>> await manager.store_memory("User likes coffee", MemoryType.PREFERENCE)
        >>> results = await manager.search_memories("coffee preferences")
    """

    def __init__(
        self,
        chroma_path: str | Path,
        sqlite_path: str | Path,
        embedding_model: str = "all-MiniLM-L6-v2",
        retention_days: int = 90,
    ) -> None:
        self.chroma_store = ChromaMemoryStore(chroma_path, embedding_model)
        self.sqlite_store = SQLiteProfileStore(sqlite_path)
        self.retention_days = retention_days

        self._current_session: SessionSummary | None = None
        self._current_user_id: str = "default"
        self._initialized = False
        self._session_lock = asyncio.Lock()  # Thread safety for session operations

    @classmethod
    def from_config(
        cls,
        chroma_path: str,
        sqlite_path: str,
        embedding_model: str = "all-MiniLM-L6-v2",
        max_memories: int = 10000,
        retention_days: int = 90,
    ) -> MemoryManager:
        """Create MemoryManager from configuration values.

        This mirrors the MemoryConfig structure from utils/config.py.
        """
        return cls(
            chroma_path=chroma_path,
            sqlite_path=sqlite_path,
            embedding_model=embedding_model,
            retention_days=retention_days,
        )

    async def initialize(self, user_id: str = "default") -> None:
        """Initialize both storage backends.

        Args:
            user_id: The user to load profile for.
        """
        log.info("Initializing memory system...")
        await self.chroma_store.initialize()
        await self.sqlite_store.initialize()
        self._current_user_id = user_id
        self._initialized = True
        log.info("Memory system initialized")

    async def close(self) -> None:
        """Close both storage backends.

        Note:
            Idempotent: safe to call multiple times.
            Thread-safe: end_session() uses asyncio.Lock internally.
        """
        # Always call end_session() - it's idempotent and handles None case
        # This avoids TOCTOU race condition from checking _current_session first
        await self.end_session()
        await self.chroma_store.close()
        await self.sqlite_store.close()
        self._initialized = False
        log.info("Memory system closed")

    # ─────────────────────────────────────────────────────────────────
    # Session Lifecycle
    # ─────────────────────────────────────────────────────────────────

    async def start_session(self, user_id: str | None = None) -> SessionSummary:
        """Start a new conversation session.

        Args:
            user_id: Optional user ID override.

        Returns:
            The new SessionSummary.

        Note:
            Thread-safe: uses asyncio.Lock to prevent concurrent session creation.
        """
        async with self._session_lock:
            if user_id:
                self._current_user_id = user_id

            session_id = str(uuid.uuid4())
            self._current_session = SessionSummary(
                session_id=session_id,
                user_id=self._current_user_id,
                start_time=datetime.now(),
            )

            await self.sqlite_store.save_session(self._current_session)
            log.info(f"Started session {session_id}")
            return self._current_session

    async def end_session(
        self,
        summary_text: str = "",
        key_topics: list[str] | None = None,
    ) -> SessionSummary | None:
        """End the current session with an optional summary.

        Args:
            summary_text: Summary of the session (can be generated by Claude).
            key_topics: List of key topics discussed.

        Returns:
            The ended SessionSummary, or None if no active session.

        Note:
            Thread-safe: uses asyncio.Lock to prevent concurrent session modification.
        """
        async with self._session_lock:
            if not self._current_session:
                log.warning("No active session to end")
                return None

            self._current_session.end_time = datetime.now()
            self._current_session.summary_text = summary_text
            self._current_session.key_topics = key_topics or []
            self._current_session.memory_count = await self.chroma_store.count()

            await self.sqlite_store.save_session(self._current_session)
            log.info(f"Ended session {self._current_session.session_id}")

            session = self._current_session
            self._current_session = None
            return session

    @property
    def current_session(self) -> SessionSummary | None:
        """Get the current active session."""
        return self._current_session

    # ─────────────────────────────────────────────────────────────────
    # Memory Operations (ChromaDB)
    # ─────────────────────────────────────────────────────────────────

    async def store_memory(
        self,
        content: str,
        memory_type: MemoryType,
        metadata: dict | None = None,
    ) -> Memory:
        """Store a new memory.

        Args:
            content: The text content to store.
            memory_type: Category of this memory.
            metadata: Optional additional metadata.

        Returns:
            The created Memory object.
        """
        # Add session context to metadata
        full_metadata = metadata or {}
        if self._current_session:
            full_metadata["session_id"] = self._current_session.session_id
        full_metadata["user_id"] = self._current_user_id

        return await self.chroma_store.store(content, memory_type, full_metadata)

    async def search_memories(
        self,
        query: str,
        n_results: int = 5,
        memory_type: MemoryType | None = None,
    ) -> list[SearchResult]:
        """Search memories by semantic similarity.

        Args:
            query: The search query text.
            n_results: Maximum number of results.
            memory_type: Optional filter by memory type.

        Returns:
            List of SearchResult objects.
        """
        return await self.chroma_store.search(query, n_results, memory_type)

    async def get_memory(self, memory_id: str) -> Memory | None:
        """Get a specific memory by ID."""
        return await self.chroma_store.get(memory_id)

    async def delete_memory(self, memory_id: str) -> bool:
        """Delete a memory by ID."""
        return await self.chroma_store.delete(memory_id)

    async def memory_count(self) -> int:
        """Get total number of memories stored."""
        return await self.chroma_store.count()

    # ─────────────────────────────────────────────────────────────────
    # Profile Operations (SQLite)
    # ─────────────────────────────────────────────────────────────────

    async def get_profile(self, user_id: str | None = None) -> UserProfile:
        """Get the user profile.

        Args:
            user_id: Optional user ID override.

        Returns:
            The UserProfile for the user.
        """
        return await self.sqlite_store.get_profile(user_id or self._current_user_id)

    async def save_profile(self, profile: UserProfile) -> None:
        """Save a user profile."""
        await self.sqlite_store.save_profile(profile)

    async def update_preference(self, key: str, value: str) -> UserProfile:
        """Update a user preference.

        Args:
            key: The preference key.
            value: The preference value.

        Returns:
            The updated UserProfile.
        """
        return await self.sqlite_store.update_preference(
            key, value, self._current_user_id
        )

    async def get_last_session(self) -> SessionSummary | None:
        """Get the most recent completed session."""
        return await self.sqlite_store.get_last_session(self._current_user_id)

    async def get_recent_sessions(self, limit: int = 10) -> list[SessionSummary]:
        """Get recent sessions."""
        return await self.sqlite_store.get_recent_sessions(
            self._current_user_id, limit
        )

    # ─────────────────────────────────────────────────────────────────
    # Maintenance
    # ─────────────────────────────────────────────────────────────────

    async def cleanup(self) -> dict[str, int]:
        """Run cleanup on old memories and sessions.

        Returns:
            Dict with counts of deleted items.
        """
        memories_deleted = await self.chroma_store.cleanup(self.retention_days)
        sessions_deleted = await self.sqlite_store.cleanup_old_sessions(
            self.retention_days
        )

        return {
            "memories_deleted": memories_deleted,
            "sessions_deleted": sessions_deleted,
        }
